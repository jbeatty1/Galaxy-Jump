<!-- 
Physics test adding the side kick. For Galaxy Jump project.

This whole code is a modified version of the part7.html example at http://phaser.io/tutorials/making-your-first-phaser-3-game/part7.
If you want to see what everything else is, I would recommend looking at the other parts in this tutorial.

This is made using the Phaser 3 game engine from https://github.com/photonstorm/phaser
-Tony Imbesi, 2/14/2022

License: https://opensource.org/licenses/MIT|MIT License
Copyright 2020 Photon Storm Ltd.

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
-->


<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>Making your first Phaser 3 Game - Part 1</title>
    <script src="phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">
var INTERVAL = 16;

// Player's movement variables:
var PVEL_MAX = 320; // Soft limit to max horizontal speed. Can be broken by various methods.
// We can get the player's velocity at any time using player.body.velocity.x
var PXACCEL = 1800; // Default horizontal acceleration
var PJUMP = -400; // Jump velocity
var PJUMP_ACCEL = -2750; // Jump acceleration. Vertical acceleration is unchanged by gravity but still affects vertical movement.
var PJUMP_BRAKE = 800; // Cancel out jump acceleration at the end of a jump
var PDRAG = 800; // Default drag
var PDRAG_AIR = 80; // Air drag
var PGRAV = 1700; // Player gravity. Total gravity = world gravity + player gravity
var KICK_VEL = 400; // Base velocity from kicking an object
var SIDEKICK_Y = -100; // Height gained from side-kicking

var tickCount = 0;
var ticksToJumpEnd = 0;
var maxJumpTicks = 15;
var isJumping = false;

var ticksToKickEnd = 0;
var maxKickTicks = 15;
var sideKick = false;

var config = {
    type: Phaser.AUTO,
    width: 1800, // Screen width
    height: 1000, // Screen height
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 0 },
            debug: true
        }
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    }
};

var game = new Phaser.Game(config);

function preload ()
{
    this.load.setBaseURL('https://labs.phaser.io');
    this.load.image('sky', 'assets/skies/sky1.png');
    this.load.image('ground', 'assets/sprites/platform.png');
    // this.load.image('star', 'assets/star.png'); // not used
    // this.load.image('bomb', 'assets/bomb.png');
    this.load.spritesheet('dude', 'assets/sprites/dude.png', { frameWidth: 32, frameHeight: 48 });
}

var platforms;
var player;
var platCollider;
var kickCollider;
var text1;
var text2;
var timer;

var pHitboxes;
var sideKickBox;

function create ()
{
    this.add.image(0, 0, 'sky').setOrigin(0, 0).setScale(2);
    
    platforms = this.physics.add.staticGroup();

    // Make the platforms
    platforms.create(600, 990, 'ground').setScale(6).refreshBody(); // Floor platform
    platforms.create(2500, 750, 'ground').setScale(4).refreshBody();
    platforms.create(-700, 700, 'ground').setScale(4).refreshBody();
    platforms.create(800, 390, 'ground').setScale(0.5).refreshBody();
    platforms.create(1200, 550, 'ground').setScale(1).refreshBody();

    // Make the preset player character
    player = this.physics.add.sprite(800, 300, 'dude');

    // Player Physics
    player.setBounce(0.5, 0); // 1st parameter is x-bounce, 2nd is y-bounce
    player.body.setGravityY(PGRAV);
    // player.body.setFrictionX(3); // I couldn't get this to work, but I'm using drag to slow the player down anyway.
    player.body.setDragX(PDRAG);

    player.setCollideWorldBounds(true);
    platCollider = this.physics.add.collider(player, platforms);    

    // Player animations. The keys can be remade using an enumeration.
    this.anims.create({
        key: 'left',
        frames: this.anims.generateFrameNumbers('dude', { start: 0, end: 3 }),
        frameRate: 10,
        repeat: -1
    });

    this.anims.create({
        key: 'turn',
        frames: [ { key: 'dude', frame: 4 } ],
        frameRate: 20
    });

    this.anims.create({
        key: 'right',
        frames: this.anims.generateFrameNumbers('dude', { start: 5, end: 8 }),
        frameRate: 10,
        repeat: -1
    });

    // This thing is similar to an input listener.
    cursors = this.input.keyboard.createCursorKeys();

    // Make the hitbox group.
    // HOW TO WORK WITH PHYSICS SHAPES IN A GROUP:
    // 1) Make the group with this.physics.add.group
    // 2) Make the rectangle with this.add.rectangle()
    // 3) Add the rectangle to the group with group.add(r1)
    // The resulting rectangle should be a physics-based member of a group
    // with a physics body, so you can operate on it like any other physics body.
    pHitboxes = this.physics.add.group();
    sideKickBox = this.add.rectangle(-10, -10, 30, 20);
    pHitboxes.add(sideKickBox);
    kickCollider = this.physics.add.overlap(pHitboxes, platforms, rebound, null, this);

    // Debug text
    text1 = this.add.text(10, 10, '', { font: '16px Courier', fill: '#00ff00' });
    text2 = this.add.text(10, 40, '', { font: '16px Courier', fill: '#00ff00' });

    timer = self.setInterval(function(){Tick()}, INTERVAL);
}



function Tick() {
    tickCount++;
}

var maxYVel = 0;
var maxXVel = 0;
var xDirection = {
    NONE: 0,
    LEFT: 1,
    RIGHT: 2,
};
var xFacing = 0;
var kickDirection = 0;
var kickAgain = true;
function update ()
{
    // Controls and movement. Could be remade into a switch statement.
    if (cursors.left.isDown)
    {
        moveX(-PXACCEL);
        xFacing = xDirection.LEFT;
        player.anims.play('left', true);
    }
    else if (cursors.right.isDown)
    {
        moveX(PXACCEL);
        xFacing = xDirection.RIGHT;
        player.anims.play('right', true);
    }
    // Else: no buttons pressed. Set acceleration to 0 and decrease speed with friction.
    else
    {
        player.setAccelerationX(0);
        player.anims.play('turn');
    }

    // Jump
    if (cursors.up.isDown && player.body.touching.down)
    {
        isJumping = true;
        player.setVelocityY(PJUMP);
        ticksToJumpEnd = tickCount + maxJumpTicks;
    }
    // Jump height increases with duration of buttom press
    if (cursors.up.isDown && isJumping && tickCount < ticksToJumpEnd)
    {
        player.setAccelerationY(PJUMP_ACCEL);
    }
    if (cursors.up.isUp || !isJumping || tickCount >= ticksToJumpEnd)
    {
        isJumping = false;
        if (player.body.velocity.y < 0) {
            player.setAccelerationY(PJUMP_BRAKE);
        }
        else {
            player.setAccelerationY(0);
        }
    }

    // Player is slowed down more on the ground
    if (player.body.touching.down){
        player.setDragX(PDRAG);
        kickAgain = true;
    }
    else {
        player.setDragX(PDRAG_AIR);
    }

    // Do a side kick
    if (cursors.space.isDown
        && !(player.body.touching.down) && !sideKick && kickAgain)
    {
        sideKick = true;
        kickAgain = false;
        // sideKickBox.enableBody(false, 0, 0, true, true);
        sideKickBox.body.setEnable(true);
        ticksToKickEnd = tickCount + maxKickTicks;
    }
    if (sideKick && tickCount < ticksToKickEnd)
    {
        alignWithPlayer(sideKickBox, 30, 0);
    }
    if (!sideKick || tickCount >= ticksToKickEnd || player.body.touching.down)
    {
        sideKick = false;
        sideKickBox.body.setEnable(false);
        kickDirection = xDirection.NONE;
    }
    if (cursors.space.isUp && !sideKick) {
        kickAgain = true;
    }

    // DEBUG: Record maximum y velocity after each fall
    if (!player.body.touching.down) {
        maxYVel = 0;
    }
    if (player.body.velocity.y > maxYVel) {
        maxYVel = player.body.velocity.y;
    }

    // DEBUG: Record maximum x velocity
    if (Math.abs(player.body.velocity.x) > maxXVel) {
        maxXVel = Math.abs(player.body.velocity.x);
    }

    // DEBUG FEATURE: Increase x-velocity with space
    // if (cursors.space.isDown)
    // {
    //     if (player.body.velocity.x > 0){
    //         player.setVelocityX(900);
    //     }
    //     else if (player.body.velocity.x < 0){
    //         player.setVelocityX(-900);
    //     }
    // }
    // DEBUG: Go back to high platform
    if (cursors.shift.isDown)
    {
        player.setPosition(800, 300);
    }
    
    // Debug text:
    text1.setText('XVel: ' + player.body.velocity.x + ' PVEL_MAX: ' + PVEL_MAX + ' XAcc: ' + player.body.acceleration.x + ' YVel: ' + player.body.velocity.y + ' Max XVel: ' + maxXVel + ' YAcc: ' + player.body.acceleration.y);
    text2.setText("TickCount: " + tickCount + " \nsideKick: " + sideKick + " kickDirection: " + kickDirection 
        + " xFacing: " + xFacing + " tickCount < ticksToKickEnd: " + (tickCount < ticksToKickEnd) + " reboundRan: " + reboundRan
        + "\nArrow keys to move left/right and jump. Press SPACE to kick off a wall. Press SHIFT to go back to the starting position.");
} // END update

/*
* Moves left or right by changing the player's acceleration.
* 
* @param ax the left or right acceleration. Negative = left, positive = right.
*
*/
var pvx = 0;
function moveX(ax)
{
    pvx = player.body.velocity.x;
    // When the player is moving beyond top speed AND trying to move in the same direction as pvx, do not accelerate any more.
    if ((-PVEL_MAX <= pvx && ax < 0) 
        || (pvx <= PVEL_MAX && ax > 0)) {
        player.setAccelerationX(ax);
    }
    else {
        player.setAccelerationX(0);
    }
} // END move

/*
* Aligns a rectangle with the player.
* 
* @param rect the rectangle
* @param xDiff the x offset: positive positions it in front of player
* @param yDiff the y offset: negative is up
*/

function alignWithPlayer(rect, xDiff, yDiff) {
    // Lock in kick direction
    if (kickDirection == xDirection.NONE) {
        kickDirection = xFacing;
    }

    if (kickDirection == xDirection.LEFT) {
        rect.setPosition(player.body.center.x - xDiff, player.body.center.y);
    }
    else if (kickDirection == xDirection.RIGHT) {
        rect.setPosition(player.body.center.x + xDiff, player.body.center.y + yDiff);
    }
}

/*
* Makes the player rebound off of an object.
* 
* @param dy the vertical velocity
* @param dx the horizontal velocity
*/
var reboundRan = 0;
function rebound()
{
    reboundRan++;
    pvx = player.body.velocity.x;
    // Left side kick: Right rebound
    if (kickDirection == xDirection.LEFT) {
        // Invert pvx if player is also moving left
        if (player.body.velocity.x < 0) {
            pvx = -pvx;
        }
        player.setVelocityX(pvx + KICK_VEL);
        xFacing = xDirection.RIGHT;
        // temporarily suppress left movement?
    }
    // Right side kick: Left rebound
    else if (kickDirection == xDirection.RIGHT) {
        // Invert pvx if player is also moving right
        if (player.body.velocity.x > 0) {
            pvx = -pvx;
        }
        player.setVelocityX(pvx - KICK_VEL);
        xFacing = xDirection.LEFT;
        // temporarily suppress right movement?
    }
    // Slight vertical boost
    player.setVelocityY(Math.min(player.body.velocity.y, SIDEKICK_Y));
    sideKick = false;
}
</script>

</body>
</html>
